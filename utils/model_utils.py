# default python packages
import logging

# our files
from models import baselines as baselines
from models import multitask as multitask

"""
Model creation code; create the appropriate model here given kwargs so as to declutter main a little
- labels2idxes: a list of lists of label2idx dictionaries for each dataset and each task this model needs
    (e.g., [[{dataset 1 task 1}, {dataset 1 task 2}], [{dataset 2 task 1}, {dataset 2 task 2}]]
- is_multilabel: a list of lists of Booleans describing whether each task above is multilabel or not
    (i.e., whether it can have more than one correct label)
- args: kwargs generated by main.py
@return: model (instance from models/), task_setting ("single" or "multi")
"""
def create_model(labels2idxes, is_multilabel, args):
    task_setting = "single" if len(labels2idxes) == 1 else "multi"

    # create model
    if args.model == "baseline":
        if len(labels2idxes) > 1:
            logging.warning("Creating a singletask model; additional tasks will be ignored.")
            task_setting = "single"

        # labels2idxes[0] better be a list with only one element; the rest are ignored anyway
        # what is sent to the model should be one number and one boolean
        kwargs = {
            "hidden_dropout_prob": args.dropout,
            "num_output_labels": len(labels2idxes[0][0]),
            "is_multilabel": is_multilabel[0][0]
        }

        logging.info("Loading BERT: {bert}".format(bert=args.plm))
       
        model = baselines.BertSingletask.from_pretrained(args.plm, **kwargs)

    elif args.model == "multitask":
        if len(labels2idxes) == 1:
            logging.warning("Creating a multitask model with only one task. Model will use multitask trappings but "
                            "really be single-task.")

        kwargs = {
            "hidden_dropout_prob": args.dropout,
            "num_output_labels": [len(l2i[0]) for l2i in labels2idxes],
            "is_multilabel": [im[0] for im in is_multilabel]
        }

        logging.info("Loading BERT/fBERT: {bert}".format(bert=args.plm))

        model = multitask.BertMultitask.from_pretrained(args.plm, **kwargs)
    else:
        raise NotImplementedError("Unknown model type: {model}".format(model=args.model))

    return model, task_setting


def set_requires_grad_model(flag: bool, *modules):
    for module in modules:
        for parameter in module.parameters():
            parameter.requires_grad = flag
    if len(modules) == 1: return modules[0]

